/*
//-----------------------------------------------------------------
 //$GPRMC,<1>,<2>,<3>,<4>,<5>,<6>,<7>,<8>,<9>,<10>,<11>,<12>*hh 
 //<1> UTC时间，hhmmss.sss(时分秒.毫秒)格式 
 //<2> 定位状态，A=有效定位，V=无效定位 
 //<3> 纬度ddmm.mmmm(度分)格式(前面的0也将被传输) 
 //<4> 纬度半球N(北半球)或S(南半球) 
 //<5> 经度dddmm.mmmm(度分)格式(前面的0也将被传输) 
 //<6> 经度半球E(东经)或W(西经) 
 //<7> 地面速率(000.0~999.9节，前面的0也将被传输) 
 //<8> 地面航向(000.0~359.9度，以正北为参考基准，前面的0也将被传输) 
 //<9> UTC日期，ddmmyy(日月年)格式 
 //<10> 磁偏角(000.0~180.0度，前面的0也将被传输) 
 //<11> 磁偏角方向，E(东)或W(西) 
 //<12> 模式指示(仅NMEA0183 3.00版本输出，A=自主定位，D=差分，E=估算，N=数据无效)
 //-----------------------------------------------------------------
 //$GPRMC,160546.000,A,3958.8450,N,11621.4676,E,0.00,,110412,,*12
 //-----------------------------------------------------------------
 */

#include <Arduino.h>
#include <SoftwareSerial.h>
#include "BBKGPS.h"

BBKGPS::BBKGPS()
{  
}
void BBKGPS::InitGPS(HardwareSerial &gpsports,int baudrates,int TimeZones)
{
  //-----------------------------------------------------------------
  TimeZone = 8;
  lengGPRMC = 100;
  HeadGPRMC = "$GPRMC";
  byteGPS = '0';
  gpsreadcount = 0;
  dotIndexs[13];
  //-----------------------------------------------------------------
  //gpsport = gpsports;
  //gpsport.begin(baudrates);
  //Serial.begin(baudrates);
  delay(200);
  TimeZone = TimeZones;
  TempValueClear();
  //----------------------------------------------------------------- 
  //-----------------------------------------------------------------
}


void BBKGPS::TempValueClear()
{
  //-----------------------------------------------------------------
  gpsreadcount = 0;
  //-----------------------------------------------------------------
  for (int i=0;i<lengGPRMC;i++){ 
    charGPRMC[i] = 0;
  }
  //-----------------------------------------------------------------
}

char BBKGPS::ReadAddGPRMC()
{
  //-----------------------------------------------------------------
  byteGPS = Serial.read();
  charGPRMC[gpsreadcount] = byteGPS;
  gpsreadcount++;
  return byteGPS;
  //-----------------------------------------------------------------
}

bool BBKGPS::CheckHeadGPRMC()
{
  //-----------------------------------------------------------------
  int bien = 0;
  for(int i=0;i<6;i++){
    //-----------------------------------------
    //Serial.print(charGPRMC[i]); 
    //Serial.print("==");
    //Serial.print(HeadGPRMC[i]);
    //Serial.println();
    //-----------------------------------------
    if( charGPRMC[i] == HeadGPRMC[i] ){ 
      bien++; 
    }
  }
  //-----------------------------------------------------------------
  if( bien == 6 ){ 
    return 1; 
  }
  return 0;
  //-----------------------------------------------------------------
}

void BBKGPS::MarkDotGPRMC()
{
  //-----------------------------------------------------------------
  int cont = 0;
  for (int i=0;i<lengGPRMC;i++){
    if ( charGPRMC[i] == ',' ){ 
      dotIndexs[cont] = i; 
      cont++; 
    }
  }
  //-----------------------------------------------------------------
}

void BBKGPS::GetDateTime(int i,int j)
{
  //-----------------------------------------------------------------
  DD = (charGPRMC[i+0]-48)*10 + (charGPRMC[i+1]-48);
  MT = (charGPRMC[i+2]-48)*10 + (charGPRMC[i+3]-48);
  YY = (charGPRMC[i+4]-48)*10 + (charGPRMC[i+5]-48);
  //-----------------------------------------------------------------
  HH = (charGPRMC[j+0]-48)*10 + (charGPRMC[j+1]-48);
  MM = (charGPRMC[j+2]-48)*10 + (charGPRMC[j+3]-48);
  SC = (charGPRMC[j+4]-48)*10 + (charGPRMC[j+5]-48);
  MS = MS+(charGPRMC[j+7]-48)*100;
  MS = MS+(charGPRMC[j+8]-48)*10; 
  MS = MS+(charGPRMC[j+9]-48);
  //-----------------------------------------------------------------
  HH = HH + TimeZone;
  if(HH>= 24){ 
    HH = HH - 24; 
    DD = DD +  1; 
  }
  //-----------------------------------------------------------------
}

float BBKGPS::GetLongLat(int j)
{
  //-----------------------------------------------------------------
  long x = 0;
  x  = ( charGPRMC[j+0] - 48 ) * 10;
  x += ( charGPRMC[j+1] - 48 );
  //-----------------------------------------------------------------
  float y = x + GetIDValue(j+2) / 60;
  //-----------------------------------------------------------------
  if( charGPRMC[j+10] == 83 ) { 
    y = (y)*-1; 
  }
  //-----------------------------------------------------------------
  return y;
  //-----------------------------------------------------------------
}

float BBKGPS::GetLongLon(int j)
{
  //-----------------------------------------------------------------
  long x = 0;
  x  = ( charGPRMC[j+0] - 48 ) * 100;
  x += ( charGPRMC[j+1] - 48 ) *  10;
  x += ( charGPRMC[j+2] - 48 );
  //-----------------------------------------------------------------
  float y = x + GetIDValue(j+3) / 60;
  //-----------------------------------------------------------------
  if( charGPRMC[j+11] == 87 ) { 
    y = (y)*-1; 
  }
  //-----------------------------------------------------------------
  return y;
  //-----------------------------------------------------------------
}

bool BBKGPS::GetGpsLock(int j)
{
  //-----------------------------------------------------------------
  if( charGPRMC[ j ] == 'A'){
    return 1;
  }
  else{
    return 0;
  }
  //-----------------------------------------------------------------
  return 0;
  //-----------------------------------------------------------------
}


float BBKGPS::GetSpedKMH(int j)
{
  return GetIDValue(j) * 1.852;
}

float BBKGPS::GetOrientD(int j)
{
  return GetIDValue(j);
}

float BBKGPS::GetIDValue(int j){
  //-----------------------------------------------------------------
  int dotIndex = 0;
  int strigEnd = 0;
  float x = 0, tempNumb = 1;
  //-----------------------------------------------------------------
  for (int i=0;i<12;i++){
    if( charGPRMC[j+i] == '.' ){ 
      dotIndex = i; 
      i=99;
    }
  }
  //-----------------------------------------------------------------
  for (int i=0;i<12;i++){
    if( charGPRMC[j+i] == ',' ){ 
      strigEnd = i;  
      i=99;
    }
  }
  //-----------------------------------------------------------------
  if( dotIndex == 0 ){ 
    return 0; 
  }
  if( strigEnd == 0 ){ 
    return 0; 
  }
  if( strigEnd <= dotIndex ){ 
    return 0; 
  }
  //-----------------------------------------------------------------
  tempNumb = 1;
  for (int i=0;i<dotIndex;i++){
    x = x + ( charGPRMC[j + dotIndex - i -1] - 48 ) * tempNumb;
    tempNumb = tempNumb * 10;
  }
  //-----------------------------------------------------------------
  tempNumb = 0.1;
  for (int i=dotIndex+1;i<strigEnd;i++){
    x = x + ( charGPRMC[j + i] - 48 ) * tempNumb;
    tempNumb = tempNumb * 0.1;
  }
  //-----------------------------------------------------------------
  return x;
  //-----------------------------------------------------------------
}





//$GPRMC,160546.000,A,3958.8450,N,11621.4676,E,0.00,,110412,,*12
//$GPRMC,000250.599,V,3958.8450,N,11621.4676,E,0.00,0.00,060180,,,N*7C
void BBKGPS::converNMEA()
{
  //-----------------------------------------------------------------
  MarkDotGPRMC();
  //-----------------------------------------------------------------
  GetDateTime(     dotIndexs[8] + 1, dotIndexs[0] + 1 );
  KK = GetGpsLock( dotIndexs[1] + 1 );
  WW = GetLongLat( dotIndexs[2] + 1 );
  JJ = GetLongLon( dotIndexs[4] + 1 );
  VV = GetSpedKMH( dotIndexs[6] + 1 );
  FF = GetOrientD( dotIndexs[7] + 1 );
  //-----------------------------------------------------------------
}

void BBKGPS::Read()
{
  //-----------------------------------------------------------------
  if( Serial.available() <= 0 ) { 
    delay(0);
  }
  //-----------------------------------------------------------------
  if( Serial.available() > 0 ) {
    //-----------------------------------------------------------------
    ReadAddGPRMC(); //read byteGPS
    //-----------------------------------------------------------------
    if( byteGPS == 13 ){
      //-----------------------------------------------------------------
      Serial.print(charGPRMC);
      if( CheckHeadGPRMC() ){ 
        converNMEA(); 
      }
      //-----------------------------------------------------------------      
      TempValueClear();
      //-----------------------------------------------------------------
    }
    if( byteGPS == 10 ){
      TempValueClear(); 
    }
    //-----------------------------------------------------------------
  }
  //-----------------------------------------------------------------	
}

